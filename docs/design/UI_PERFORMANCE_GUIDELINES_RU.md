# Рекомендации по производительности UI (HeadUnit OS)

Этот документ описывает ограничения и лучшие практики разработки веб-интерфейсов для оборудования CoffeeDigital Reborn HeadUnit (Raspberry Pi 4/5).

## 1. Аппаратный контекст и вызовы

### Целевое разрешение: 2880 x 824 (Ultrawide)

Хотя тестирование часто проводится в 1920x1080 (2.07 млн пикселей), финальный дисплей имеет разрешение 2880x824 (2.37 млн пикселей). Это **увеличение количества пикселей на 15%**. Каждый кадр требует больше работы от GPU, особенно для операций, зависящих от скорости заполнения (fill-rate).

### Графическая архитектура

- **Композитор**: Cage (Wayland) + wlroots.
- **Рендерер**: V3D (OpenGL ES 3.1 / Vulkan).
- **Драйвер**: Mesa.
- **Ограничения**: Основным «узким местом» является пропускная способность памяти. Сложное смешивание слоев (blending) и фильтры могут быстро снизить частоту кадров ниже 60 FPS.

---

## 2. Оптимизация CSS («Золотые правила»)

### ❌ Чего стоит избегать (Убийцы производительности)

- **`backdrop-filter` (Blur)**: Это убийца производительности №1. Полностью избегайте его для HeadUnit. Он заставляет GPU считывать буфер кадра, применять размытие и компоновать его обратно каждый кадр.
- **Тяжелые `box-shadow`**: Большие, размытые тени (например, `box-shadow: 0 0 50px ...`) очень дороги при отрисовке. Используйте небольшие, резкие тени или предварительно отрисованные изображения (glow) для эффектов свечения.
- **`filter: drop-shadow()`**: Еще дороже, чем `box-shadow`.
- **Сложные градиенты**: Глубоко вложенные линейные/радиальные градиенты могут замедлить растеризацию.
- **Fixed/Sticky Position во время прокрутки**: Вызывает массовые перерисовки.

### ✅ Что использовать (Аппаратное ускорение)

- **`transform`**: Используйте для перемещения, масштабирования и поворота (например, `translate3d(0,0,0)` для принудительного создания нового слоя).
- **`opacity`**: Используйте для эффектов прозрачности.
- **`will-change: transform, opacity`**: Используйте только для элементов, которые анимируются часто, чтобы помочь Chromium заранее выделить слои.

---

## 3. Лучшие практики React / Frontend

### Количество DOM-узлов

Держите дерево DOM плоским. Железо RPi с трудом справляется с расчетами макета (layout), если DOM слишком глубокий (например, > 1000 узлов). Используйте виртуализацию (напр. `react-window`) для списков.

### Анимации

- Используйте **CSS Transitions/Animations** для простых состояний UI.
- Используйте **Framer Motion** или **GSAP** экономно. Убедитесь, что они используют только свойства с аппаратным ускорением.
- Отдавайте предпочтение `requestAnimationFrame` перед `setTimeout` для логики на JS.

### Ресурсы и медиа

- **Иконки**: Используйте SVG. Избегайте иконочных шрифтов (они обрабатываются как текст и перерисовываются целиком).
- **Изображения**: Используйте формат WebP. Убедитесь, что размеры изображений соответствуют их экранному размеру (не загружайте 4K картинку в контейнер 200px).
- **Видео**: Используйте H.264/AVC для лучшей поддержки аппаратного декодирования.

---

## 4. Конфигурация Chromium (Kiosk Mode)

Мы используем специальные флаги для обеспечения высокой производительности. Не удаляйте их без необходимости:

- `--canvas-oop-rasterization`: Растеризует Canvas 2D вне основного потока.
- `--ignore-gpu-blocklist`: Принудительно использует GPU, даже если Chromium считает драйвер небезопасным.
- `--enable-gpu-rasterization`: Критично для плавной прокрутки и анимаций.
- `--enable-zero-copy`: Снижает количество копирований памяти между CPU и GPU.

---

## 5. Отладка производительности

Если интерфейс кажется «дерганым»:

1. Проверьте `chrome://gpu`, чтобы убедиться, что "Hardware accelerated" активно.
2. Откройте DevTools (через SSH туннель) и используйте вкладку **Performance**.
3. Ищите **Long Tasks** (красные полосы) и **Layout Thrashing**.
4. Проверьте **Paint Flashing** во вкладке Rendering, чтобы увидеть лишние перерисовки.

> [!TIP] > **Практическое правило**: Если интерфейс не работает плавно (60 FPS) на вашем рабочем компьютере при ограничении CPU "6x slowdown" в DevTools, он точно будет тормозить на Raspberry Pi.
